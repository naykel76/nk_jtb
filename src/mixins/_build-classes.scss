@use '../functions/classes' as *;
@use '../functions/strings' as *;
@use '../functions/resolvers' as *;
@use '../mixins/make-classes' as *;
@use '../mixins/property-makers' as *;
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
@use 'sass:meta';

@mixin build-composite-classes($properties-map, $responsive: false) {
    @each $class, $map in $properties-map {
        $props: map.get($map, 'props');
        $map-breakpoints: map.get($map, 'breakpoints'); // optional
        // if responsive is true, get the breakpoints from the map or use the default
        $breakpoints: if($responsive, get-breakpoints($map-breakpoints), $map-breakpoints);

        .#{$class} {
            @include make-properties($props);
        }

        @if $breakpoints {
            @include make-from-breakpoint($props, $class, $breakpoints);
        }
    }
}

// ============================================================================
// Generates utility classes for CSS properties using a configuration map.
// Supports responsive variants, automatic value-unit handling, position-based 
// classes, and optional axis key omission for cleaner class names.
// --------------------------------------------------------------------------
// Units in class names are controlled by:
// - 'rem' units are always stripped (default unit)
// - Properties in $unit-omitted-from-class have all units stripped
//   (e.g., border-width â†’ 'bdr-1' instead of 'bdr-1px')
// - Other units are appended (e.g., 'w-600px')
// ============================================================================

// prettier-ignore
@mixin build-classes($properties-map, $responsive: false, $with-state: false, $debug: false) {
    // NK?? add option to create different responsive builds. (on, from, to)
    // - should this be done on a per-property basis?
    // - should this be done on a global basis?

    @each $property, $config in $properties-map {
        $config-unit: map.get($config, 'unit');
        $config-positions: map.get($config, 'positions');
        $omit-axis-keys: map.get($config, 'omit-axis-keys'); 
        $child-combinator: map.get($config, 'child-combinator');

        $prefix: resolve-prefix(map.get($config, 'prefix'), $property);
        $breakpoints: resolve-breakpoints($responsive, map.get($config, 'breakpoints'));
        $states: resolve-states($with-state, map.get($config, 'states'));

        @each $key, $value in map.get($config, 'values') {
            // Normalize each key-value pair to ensure consistent variant label and value
            // for reliable class generation across different input formats
            $item: normalise-variant-value($key, $value);
            $label: list.nth($item, 1);
            $value: list.nth($item, 2);

            // Process the value and create class name components
            $derived-unit: if(value-has-unit($value), null, ($config-unit)); 
            $derived-value: #{handle-class-value($value, $derived-unit)}; 
            $derived-suffix: #{$label}#{handle-class-unit($derived-unit, $property)}; 

            // then clean up any unwanted suffixes
            $derived-class: strip-class-suffixes(#{$prefix}#{$derived-suffix});

            @if $config-positions {
                @include make-position-based-class($property, $derived-value, $config-positions, $prefix, $derived-suffix, $breakpoints, $states, $omit-axis-keys, $child-combinator);
            } @else{
                @include make-single-property-class( $property, #{$derived-class}, #{$derived-value}, $breakpoints, $states, $child-combinator );
            }
        }
    }
}

@mixin debug-property-classes($properties-map, $responsive: false, $with-state: false, $show-classes: false) {
    @each $property, $map in $properties-map {
        $map-unit: map.get($map, 'unit');
        $map-positions: map.get($map, 'positions');

        $prefix: resolve-prefix(map.get($map, 'prefix'), $property);
        $breakpoints: resolve-breakpoints($responsive, map.get($map, 'breakpoints'));
        $states: resolve-states($with-state, map.get($map, 'states'));

        DEBUG #{$property} {
            /** Map Render Options */
            --responsive: #{$responsive};
            --with-state: #{$with-state};

            /** Map Item Details */
            --property-name: #{$property};
            --values-count: #{list.length(map.get($map, 'values'))};
            --resolved-prefix: #{if($prefix != '', $prefix, 'NONE')};
            --resolved-breakpoints: #{if($breakpoints != null, meta.inspect($breakpoints), 'NONE')};
            --resolved-states: #{if($states != null, meta.inspect($states), 'NONE')};

            // --map-positions: #{if($map-positions, meta.inspect($map-positions), 'NONE')};
            // --map-unit: #{if($map-unit, $map-unit, 'NONE')};

            @if $show-classes {
                @each $key, $value in map.get($map, 'values') {
                    $item: normalise-variant-value($key, $value);
                    $label: list.nth($item, 1);
                    $value: list.nth($item, 2);

                    $derived-unit: if(value-has-unit($value), null, ($map-unit));
                    $derived-suffix: #{$label}#{handle-class-unit($derived-unit)};
                    $derived-class: strip-class-suffixes(#{$prefix}#{$derived-suffix});

                    --class: #{$derived-class};
                }
            }
        }
    }
}
