@use '../functions/classes' as *;
@use '../functions/strings' as *;
@use '../mixins/class-makers' as *;
@use '../mixins/property-makers' as *;
@use '../mixins/helpers' as *;
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
@use 'sass:meta';

@mixin build-composite-classes($properties-map, $responsive: false) {
    @each $class, $map in $properties-map {
        $props: map.get($map, 'props');
        $map-breakpoints: map.get($map, 'breakpoints'); // optional
        // if responsive is true, get the breakpoints from the map or use the default
        $breakpoints: if($responsive, get-breakpoints($map-breakpoints), $map-breakpoints);

        .#{$class} {
            @include make-properties($props);
        }

        @if $breakpoints {
            @include make-from-breakpoint($props, $class, $breakpoints);
        }
    }
}

// ==========================================================================
// Generates utility classes for CSS properties using a configuration map.
// Supports responsive variants, automatic value-unit handling, and
// position-based classes.
// --------------------------------------------------------------------------
// Key variables in the value processing logic:
//
// 1. $derived-unit: Prevents double-unit application by checking if the $value
//    already includes a unit (12px, 1em, 100vh, etc.). If it does,
//    $derived-unit is set to null to avoid adding the map's unit. If it doesn't,
//    $derived-unit is set to $map-unit to apply the default unit.
//
// 2. $derived-value: The final processed CSS value for the property, created by
//    combining the original $value with the appropriate unit (if needed). This
//    ensures values are properly formatted for CSS output.
//
// 3. $derived-suffix: The unique identifier portion of the class name, created
//    by combining the variant label with the processed unit string. This forms
//    the distinctive part of each utility class (e.g., "12px" in "margin-12px").
// ==========================================================================

// prettier-ignore
@mixin build-property-classes($properties-map, $responsive: true, $with-state: false, $debug: false) {
    @each $property, $map in $properties-map {
        $map-unit: map.get($map, 'unit');
        $map-positions: map.get($map, 'positions');

        $prefix: resolve-prefix(map.get($map, 'prefix'), $property);
        $breakpoints: resolve-breakpoints($responsive, map.get($map, 'breakpoints'));
        $states: resolve-states($with-state, map.get($map, 'states'));

        @each $key, $value in map.get($map, 'values') {
            // Normalize each key-value pair to ensure consistent variant label and value
            // for reliable class generation across different input formats
            $item: normalise-variant-value($key, $value);
            $label: list.nth($item, 1);
            $value: list.nth($item, 2);

            // Process the value and create class name components
            $derived-unit: if(value-has-unit($value), null, ($map-unit)); // 1.
            $derived-value: #{handle-class-value($value, $derived-unit)}; // 2.
            $derived-suffix: #{$label}#{handle-class-unit($derived-unit)}; // 3.

            // Generate the final class name by combining prefix and suffix,
            // then clean up any unwanted suffixes
            $derived-class: strip-class-suffixes(#{$prefix}#{$derived-suffix});

            // always create individual directions and avoid shorthands like
            // margin-inline, margin-block, and margin. This ensures maximum
            // flexibility and avoids unintended overrides in complex layouts.
            @if $map-positions {
                @include make-position-based-class($property, $derived-value, $map-positions, $prefix, $derived-suffix, $breakpoints);
            } @else{
                @include make-single-property-class( $property, #{$derived-class}, #{$derived-value}, $breakpoints, $states );
            }
        }
    }
}

@mixin debug-property-classes($properties-map, $responsive: false, $with-state: false, $show-classes: false) {
    @each $property, $map in $properties-map {
        $map-unit: map.get($map, 'unit');
        $map-positions: map.get($map, 'positions');

        $prefix: resolve-prefix(map.get($map, 'prefix'), $property);
        $breakpoints: resolve-breakpoints($responsive, map.get($map, 'breakpoints'));
        $states: resolve-states($with-state, map.get($map, 'states'));

        DEBUG #{$property} {
            /** Map Render Options */
            --responsive: #{$responsive};
            --with-state: #{$with-state};

            /** Map Item Details */
            --property-name: #{$property};
            --values-count: #{list.length(map.get($map, 'values'))};
            --resolved-prefix: #{if($prefix != '', $prefix, 'NONE')};
            --resolved-breakpoints: #{if($breakpoints != null, meta.inspect($breakpoints), 'NONE')};
            --resolved-states: #{if($states != null, meta.inspect($states), 'NONE')};

            // --map-positions: #{if($map-positions, meta.inspect($map-positions), 'NONE')};
            // --map-unit: #{if($map-unit, $map-unit, 'NONE')};

            @if $show-classes {
                @each $key, $value in map.get($map, 'values') {
                    $item: normalise-variant-value($key, $value);
                    $label: list.nth($item, 1);
                    $value: list.nth($item, 2);

                    $derived-unit: if(value-has-unit($value), null, ($map-unit));
                    $derived-suffix: #{$label}#{handle-class-unit($derived-unit)};
                    $derived-class: strip-class-suffixes(#{$prefix}#{$derived-suffix});

                    --class: #{$derived-class};
                }
            }
        }
    }
}
