// stylelint-disable scss/at-else-closing-brace-newline-after
// stylelint-disable scss/at-else-closing-brace-space-after
// stylelint-disable scss/at-if-closing-brace-newline-after
// stylelint-disable scss/at-if-closing-brace-space-after
@use '../functions/classes' as *;
@use '../mixins/media-container-queries' as *;
@use '../mixins/make-properties' as *;
@use '../functions/strings' as *;
@use 'sass:map';
@use 'sass:list';
@use 'sass:meta';

// ============================================================================
// Layer 2: Responsive only (no base, no states)
// ============================================================================
// Properties that use split pattern: border-{position}-{end} instead of
// {property}-{position} Example: border-top-width instead of border-width-top
// ============================================================================
// this is confusing naming, but the idea is that some properties have different
// patterns for position-based variants. we need to know which ones to handle
// them correctly.
$split-properties: ('border-width', 'border-style', 'border-color', 'border-radius');

// ============================================================================
// Build position-aware property name based on pattern
// Split pattern: border-{position}-width | Suffix pattern: margin-{position}
// ============================================================================
@function get-position-property($property, $position) {
    @if list.index($split-properties, $property) {
        $property-start: str-first-segment($property);
        $property-end: str-last-segment($property);

        @return #{$property-start}-#{$position}-#{$property-end};
    }

    @return #{$property}-#{$position};
}

// ============================================================================
// Layer 1: Base only
// ============================================================================
@mixin make-base-class($property, $class, $value, $positions: null, $options: ()) {
    $child-selector: if(map.has-key($options, 'child-selector'), map.get($options, 'child-selector'), false);

    @if $positions {
        $prefix: map.get($options, 'prefix');
        $variant: map.get($options, 'variant');
        $omit-axis-keys: if(map.has-key($options, 'omit-axis-keys'), map.get($options, 'omit-axis-keys'), false);

        @each $position-key, $position-list in $positions {
            $derived-class: build-position-class-name($prefix, $variant, $position-key, $omit-axis-keys);
            $props: build-property-map($property, $position-list, $value, meta.get-function('get-position-property'));
            #{build-selector($derived-class, $child-selector)} {
                @include make-properties($props);
            }
        }
    } @else {
        #{build-selector($class, $child-selector)} {
            #{$property}: $value;
        }
    }
}

// ============================================================================
// Layer 2: Responsive only (no base, no states)
// Handles both simple properties and position-based variants
// ============================================================================
// prettier-ignore
@mixin make-responsive-class($property, $class, $value, $positions: null, $breakpoints, $options: ()) {
    $child-selector: if(map.has-key($options, 'child-selector'), map.get($options, 'child-selector'), false);

    @each $bp in $breakpoints {
        $derived-class: #{$bp}\:#{$class};

        #{build-selector($derived-class, $child-selector)} {
            @if $bp == 'sm' {
                @include from-sm {
                    @if $positions {
                        $props: build-property-map( $property, $positions, $value, meta.get-function('get-position-property') );

                        @include make-properties($props);
                    } @else {
                        #{$property}: $value;
                    }
                }
            } @else if $bp == 'md' {
                @include from-md {
                    @if $positions {
                        $props: build-property-map( $property, $positions, $value, meta.get-function('get-position-property') );

                        @include make-properties($props);
                    } @else {
                        #{$property}: $value;
                    }
                }
            } @else if $bp == 'lg' {
                @include from-lg {
                    @if $positions {
                        $props: build-property-map( $property, $positions, $value, meta.get-function('get-position-property') );

                        @include make-properties($props);
                    } @else {
                        #{$property}: $value;
                    }
                }
            } @else if $bp == 'xl' {
                @include from-xl {
                    @if $positions {
                        $props: build-property-map( $property, $positions, $value, meta.get-function('get-position-property') );

                        @include make-properties($props);
                    } @else {
                        #{$property}: $value;
                    }
                }
            } @else if $bp == 'xxl' {
                @include from-xxl {
                    @if $positions {
                        $props: build-property-map( $property, $positions, $value, meta.get-function('get-position-property') );

                        @include make-properties($props);
                    } @else {
                        #{$property}: $value;
                    }
                }
            }
        }
    }
}

// ============================================================================
// Layer 3: States only (no base, no responsive)
// Generates: .hover:block:hover { display: block; }
// ============================================================================
@mixin make-state-class($property, $class, $value, $states, $options: ()) {
    @each $state in $states {
        .#{$state}\:#{$class}:#{$state} {
            #{$property}: $value;
        }
    }
}

// ============================================================================
// Layer 4: Responsive + State (no base, no solo variants)
// Generates: .md:hover:block:hover { @media (min-width: 768px) { display: block; } }
// ============================================================================
@mixin make-responsive-state-class($property, $class, $value, $breakpoints, $states, $options: ()) {
    $child-selector: if(map.has-key($options, 'child-selector'), map.get($options, 'child-selector'), false);

    @each $bp in $breakpoints {
        @each $state in $states {
            $derived-class: #{$bp}\:#{$state}\:#{$class};

            #{build-selector($derived-class, $child-selector)} {
                @if $bp == 'sm' {
                    @include from-sm {
                        &:#{$state} {
                            #{$property}: $value;
                        }
                    }
                } @else if $bp == 'md' {
                    @include from-md {
                        &:#{$state} {
                            #{$property}: $value;
                        }
                    }
                } @else if $bp == 'lg' {
                    @include from-lg {
                        &:#{$state} {
                            #{$property}: $value;
                        }
                    }
                } @else if $bp == 'xl' {
                    @include from-xl {
                        &:#{$state} {
                            #{$property}: $value;
                        }
                    }
                } @else if $bp == 'xxl' {
                    @include from-xxl {
                        &:#{$state} {
                            #{$property}: $value;
                        }
                    }
                }
            }
        }
    }
}
