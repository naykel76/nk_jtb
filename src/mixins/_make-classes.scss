@use '../functions/classes' as *;
@use '../mixins/media' as *;
@use '../mixins/property-makers' as *;
@use '../functions/strings' as *;
@use 'sass:map';
@use 'sass:list';

// ==========================================================================
// Generate class for a single property and optionally creates responsive
// classes for a range of breakpoints.
// --------------------------------------------------------------------------
// NOTE: This mixin will create the base class as well as responsive classes.
// ==========================================================================
// prettier-ignore
@mixin make-single-property-class($property, $class-name, $value, $breakpoints: (), $states: ()) {
    .#{$class-name} {
        #{$property}: $value;
    }

    @if $breakpoints {
        @include make-from-breakpoint( ( $property: $value ), $class-name, $breakpoints );
    }

    @if $states {
        @include make-state-based-class( ( $property: $value ), $class-name, $states );
    }
}

@mixin make-state-based-class($props, $class-name, $states) {
    @each $state in $states {
        .#{$state}\:#{$class-name}:#{$state} {
            @include make-properties($props);
        }
    }
}

// ==========================================================================
// Generate responsive class for one or more properties, starting FROM the
// specified breakpoints, across a range of breakpoints.
// --------------------------------------------------------------------------
//
// ==========================================================================
@mixin make-from-breakpoint($props, $identifier, $breakpoints) {
    @each $bp in $breakpoints {
        $derived-class: #{$bp}\:#{$identifier};
        .#{$derived-class} {
            @if $bp == 'sm' {
                @include from-sm {
                    @include make-properties($props);
                }
            } @else if $bp == 'md' {
                @include from-md {
                    @include make-properties($props);
                }
            } @else if $bp == 'lg' {
                @include from-lg {
                    @include make-properties($props);
                }
            } @else if $bp == 'xl' {
                @include from-xl {
                    @include make-properties($props);
                }
            } @else if $bp == 'xxl' {
                @include from-xxl {
                    @include make-properties($props);
                }
            }
        }
    }
}

// ==========================================================================
// Generate responsive classes for one or more properties, up TO the specified
// breakpoints, across a range of breakpoints.
// --------------------------------------------------------------------------
//
// @param {Map} $props - The map of properties and values.
// @param {String} $identifier - A part of the base class name.
// @param {List} $breakpoints - The list of breakpoints.
// ==========================================================================
@mixin make-to-breakpoint($props, $identifier, $breakpoints) {
    @each $bp in $breakpoints {
        $derived-class: #{$bp}\:#{$identifier};
        .to-#{$derived-class} {
            @if $bp == 'sm' {
                @include to-sm {
                    @include make-properties($props);
                }
            } @else if $bp == 'md' {
                @include to-md {
                    @include make-properties($props);
                }
            } @else if $bp == 'lg' {
                @include to-lg {
                    @include make-properties($props);
                }
            } @else if $bp == 'xl' {
                @include to-xl {
                    @include make-properties($props);
                }
            } @else {
                @error 'The device '#{$bp}' is not available for this mixin, you need to remove it from the args list.';
            }
        }
    }
}

// ==========================================================================
// Generate responsive classes for one or more properties, starting ON the
// specified breakpoints, across a range of breakpoints.
// --------------------------------------------------------------------------
//
// ==========================================================================
@mixin make-on-breakpoint($props, $identifier, $breakpoints) {
    @each $bp in $breakpoints {
        $derived-class: #{$bp}\:#{$identifier};
        .on-#{$derived-class} {
            @if $bp == 'sm' {
                @include on-sm {
                    @include make-properties($props);
                }
            } @else if $bp == 'md' {
                @include on-md {
                    @include make-properties($props);
                }
            } @else if $bp == 'lg' {
                @include on-lg {
                    @include make-properties($props);
                }
            } @else if $bp == 'xl' {
                @include on-xl {
                    @include make-properties($props);
                }
            } @else if $bp == 'xxl' {
                @include on-xxl {
                    @include make-properties($props);
                }
            }
        }
    }
}

// leave for future use
// 'border-color': 'color',
// 'scroll-margin': null,
// 'scroll-padding': null,
// 'outline-width': 'width',
// 'outline-color': 'color',
// 'outline-style': 'style'

// List of properties that use the split pattern for position-based classes
$split-properties: ('border-width', 'border-style', 'border-color', 'border-radius');

@function get-position-property($property, $position) {
    // Check if this property uses the split pattern
    @if list.index($split-properties, $property) {
        $property-start: str-first-segment($property);
        $property-end: str-last-segment($property);

        @return #{$property-start}-#{$position}-#{$property-end};
    }

    // Otherwise use suffix pattern
    @return #{$property}-#{$position};
}

// ==========================================================================
// Generate position-based utility classes with optional axis key omission
// --------------------------------------------------------------------------
// Creates utility classes for CSS properties that apply to multiple positions
// (e.g., padding, margin, border). Supports omitting specific axis keys from
// class names for cleaner, more semantic class names.
//
// @param {String} $property - The base CSS property name
// @param {String} $value - The CSS value to apply
// @param {Map} $positions-map - Map of position keys to CSS positions
// @param {String} $identifier - Base class identifier/prefix
// @param {String} $variant - Variant suffix for the class name
// @param {List} $breakpoints - List of responsive breakpoints
// @param {List} $states - List of pseudo-class states
// @param {List} $omit-axis-keys - List of axis keys to omit from class names
//
// @example scss - Basic usage with omit-axis-keys
//   $positions: (xy: (top, bottom, left, right), x: (left, right));
//   @include make-position-based-class(
//     'padding', '1rem', $positions, 'p-', '1', (), (), (xy)
//   );
//   // Generates: .p-1 (instead of .p-xy-1) and .p-x-1
//
// @example scss - Without omit-axis-keys (default behavior)
//   @include make-position-based-class(
//     'margin', '1rem', $positions, 'm-', '1', (), (), ()
//   );
//   // Generates: .m-xy-1 and .m-x-1 (includes all axis keys)
// ==========================================================================
@mixin make-position-based-class($property, $value, $positions-map, $identifier, $variant, $breakpoints, $states: (), $omit-axis-keys: ()) {
    // Iterate through each axis or position grouping in the positions map
    @each $position-key, $positions in $positions-map {
        // Initialize props map to collect all properties for responsive classes
        $props: ();

        // Check if this position key should be omitted from the class name
        $should-omit-key: false;

        @if $omit-axis-keys {
            @each $omit-key in $omit-axis-keys {
                @if $position-key == $omit-key {
                    $should-omit-key: true;
                }
            }
        }

        // Generate clean class name by stripping unwanted suffixes
        // If the axis key should be omitted, don't include it in the class name
        $derived-class: null;

        @if $should-omit-key {
            $derived-class: strip-class-suffixes(#{$identifier}#{$variant}, $identifier);
        } @else {
            $derived-class: strip-class-suffixes(#{$identifier}#{$position-key}-#{$variant}, $identifier);
        }

        .#{$derived-class} {
            @each $position in $positions {
                $css-property: get-position-property($property, $position);

                #{$css-property}: #{$value};

                // Collect each property-value pair into props map for responsive class generation
                $props: map.merge($props, (#{$css-property}: $value));
            }
        }

        @if $breakpoints {
            @include make-from-breakpoint($props, $derived-class, $breakpoints);
        }
    }
}
